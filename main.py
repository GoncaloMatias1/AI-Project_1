import random
import math
import pandas as pd

from simulation import (generate_airplane_stream, schedule_landings, evaluate_landing_schedule, get_successors, get_Hill_Tabu_successors)
from simulation import GeneticAlgorithmScheduler

def get_input(prompt, type_=None, min_=None, max_=None, header=None):
    while True:
        if header:
            print("\n" + "-" * 72)
            print("|" + header.center(70) + "|")
            print("-" * 72)
        try:
            value = input("| " + prompt.ljust(68) + "| ")
            print("-" * 72)
            if type_ is not None:
                value = type_(value)
            if (min_ is not None and value < min_) or (max_ is not None and value > max_):
                raise ValueError(f"Value should be between {min_} and {max_}.")
            return value
        except ValueError as e:
            print("|" + f"Invalid input: {e}".center(70) + "|")
            print("-" * 72)



def select_algorithm():
    print("\n" + "-" * 72)
    print("|" + "Airport Landing Scheduler".center(70) + "|")
    print("|" + "Optimization Algorithm Selection".center(70) + "|")
    print("-" * 72)
    print("|" + "1 - Hill Climbing".ljust(69) + "|")
    print("|" + "2 - Simulated Annealing".ljust(69) + "|")
    print("|" + "3 - Tabu Search".ljust(69) + "|")
    print("|" + "4 - Genetic Algorithm".ljust(69) + "|")
    print("-" * 72)
    choice = get_input("Enter your choice (number): ", type_=int, min_=1, max_=4)  # Update max_=4
    return choice



"""
Optimize the landing schedule for airplanes using hill climbing.

This function applies the hill climbing algorithm to improve the landing schedule for airplanes. Hill climbing is a local search algorithm that iteratively moves towards the best neighboring solution in the solution space.

The algorithm marks urgent airplanes based on their fuel levels and expected landing times. It generates an initial landing schedule using the 'schedule_landings' function and initializes the current score along with a list to store scores.

The function repeatedly explores neighboring landing schedules until no improvement is found. It selects the neighboring schedule with the lowest score, assuming it as the next state. If the next score is equal to the current score, indicating no improvement, the search terminates.

The function returns the optimized landing schedule along with an empty list of scores, as hill climbing does not record scores during the search process.

@param airplane_stream: A list of airplanes to schedule for landing.
@type airplane_stream: list[Airplane]
@return: A tuple containing the optimized landing schedule (DataFrame) and an empty list of scores.
@rtype: tuple(pandas.DataFrame, list)
"""


def hill_climbing_schedule_landings(airplane_stream):
    

    # Mark urgent airplanes based on their fuel levels and expected landing times.
    for airplane in airplane_stream:
        airplane.is_urgent = (airplane.fuel_level_final < airplane.emergency_fuel or
                                airplane.remaining_flying_time < airplane.expected_landing_time)

    # Generate an initial landing schedule using the schedule_landings function.
    landing_schedule_df = schedule_landings(airplane_stream)

    # Initialize the current score and a list to store the scores of each iteration.
    current_score = evaluate_landing_schedule(landing_schedule_df, airplane_stream)
    scores = []

    # Repeat the following steps until no improvement is found.
    while True:
        #Get all neighboring landing schedules from the current schedule.
        neighbors = get_Hill_Tabu_successors(landing_schedule_df, airplane_stream)

        # Assume the next state is the same as the current state and track the lowest score.
        next_state_df = landing_schedule_df
        next_score = current_score

        # Iterate over the neighboring landing schedules and find the one with the lowest score.
        for neighbor_df in neighbors:
            score = evaluate_landing_schedule(neighbor_df, airplane_stream)
            if score < next_score:
                next_state_df = neighbor_df
                next_score = score

        if next_score == current_score:
            break

        landing_schedule_df = next_state_df
        current_score = next_score

    return landing_schedule_df, scores


"""
Optimize the landing schedule for airplanes using simulated annealing.

This function applies the simulated annealing algorithm to improve the landing schedule for airplanes. Simulated annealing is a technique inspired by metallurgy annealing, gradually reducing temperature to explore the solution space while avoiding local optima.

The algorithm begins with an initial landing schedule generated by 'schedule_landings'. It iteratively adjusts the schedule to improve its score, considering both better and worse solutions based on a probability function and current temperature.

@param airplane_stream: A list of airplanes to schedule for landing.
@type airplane_stream: list[Airplane]
@return: A tuple containing the optimized landing schedule (DataFrame) and its score.
@rtype: tuple(pandas.DataFrame, float)
"""


def simulated_annealing_schedule_landings(airplane_stream):
    def calculate_score(schedule_df, airplane_stream):
        for index, row in schedule_df.iterrows():
            airplane = next((ap for ap in airplane_stream if ap.id == row['Airplane ID']), None)
            if airplane:
                time_diff = abs(airplane.expected_landing_time - row['Actual Landing Time'])
                urgency_penalty = 100 if airplane.is_urgent else 0
                score = 1000 - time_diff - urgency_penalty
                schedule_df.at[index, 'Score'] = score
        return schedule_df

    def get_schedule_neighbor(schedule_df):
        neighbor_df = schedule_df.copy()
        i, j = random.sample(range(len(neighbor_df)), 2)
        neighbor_df.iloc[i], neighbor_df.iloc[j] = neighbor_df.iloc[j].copy(), neighbor_df.iloc[i].copy()
        return neighbor_df

    current_schedule = schedule_landings(airplane_stream)
    current_schedule = calculate_score(current_schedule, airplane_stream)
    current_score = current_schedule['Score'].sum()
    best_schedule = current_schedule
    best_score = current_score
    T = 1.0  # Initial high temperature
    T_min = 0.001  # Minimum temperature
    alpha = 0.9  # Cooling rate

    while T > T_min:
        new_schedule = get_schedule_neighbor(current_schedule)
        new_schedule = calculate_score(new_schedule, airplane_stream)
        new_score = new_schedule['Score'].sum()
        if new_score > current_score or math.exp((new_score - current_score) / T) > random.random():
            current_schedule = new_schedule
            current_score = new_score
            if new_score > best_score:
                best_schedule = new_schedule
                best_score = new_score
        T *= alpha  # Cool down

    return best_schedule, best_score


"""
Optimize the landing schedule for airplanes using tabu search.

This function applies the tabu search algorithm to improve the landing schedule for airplanes. Tabu search is a metaheuristic search method that guides the search process to explore the solution space efficiently while avoiding getting trapped in local optima.

The algorithm begins by determining if an airplane is urgent based on its fuel level and remaining flying time. It then initializes variables, including the landing schedule, current score, a list of scores, and a tabu list.

The function iterates through the search process until it reaches the maximum number of iterations specified. During each iteration, it generates neighboring solutions from the current solution and evaluates their scores. It selects the best solution among neighbors and considers it for the next iteration while also considering solutions in the tabu list.

The search process continues until the maximum number of iterations is reached. The function returns the optimized landing schedule along with a list of scores recorded during the search process.

@param airplane_stream: A list of airplanes to schedule for landing.
@type airplane_stream: list[Airplane]
@param max_iterations: The maximum number of iterations for the tabu search algorithm. Default is 1000.
@type max_iterations: int, optional
@param max_tabu_size: The maximum size of the tabu list. Default is 10.
@type max_tabu_size: int, optional
@return: A tuple containing the optimized landing schedule (DataFrame) and a list of scores recorded during the search process.
@rtype: tuple(pandas.DataFrame, list[float])
"""


def tabu_search_schedule_landings(airplane_stream, max_iterations=1000, max_tabu_size=10):
    for airplane in airplane_stream:
        airplane.is_urgent = airplane.fuel_level_final < airplane.emergency_fuel or airplane.remaining_flying_time < airplane.expected_landing_time
    
    landing_schedule_df = schedule_landings(airplane_stream)
    current_score = evaluate_landing_schedule(landing_schedule_df, airplane_stream)
    scores = []
    tabu_list = []
    it = 0

    while it < max_iterations:
        neighbors = get_Hill_Tabu_successors(landing_schedule_df, airplane_stream)
        next_state_df = landing_schedule_df
        scores.append(current_score)
        next_score = current_score

        best_solution_df = landing_schedule_df
        best_solution_score = evaluate_landing_schedule(landing_schedule_df, airplane_stream)

        for neighbor_df in neighbors:
            neighbor_string = neighbor_df.to_string()
            score = evaluate_landing_schedule(neighbor_df, airplane_stream)
            if score < best_solution_score:
                best_solution_df = neighbor_df
                best_solution_score = score
            if neighbor_string not in tabu_list:
                if score < next_score:
                    next_state_df = neighbor_df
                    next_score = score
                tabu_list.append(neighbor_string)  # Add the neighbor to the tabu list as soon as it's generated
                if len(tabu_list) > max_tabu_size:
                    tabu_list.pop(0)

        if next_score >= current_score:
            if random.random() < 0.1:  # 10% chance to choose a random neighbor
                next_state_df = random.choice(neighbors)
                next_score = evaluate_landing_schedule(next_state_df, airplane_stream)
            else:
                next_state_df = best_solution_df
                next_score = best_solution_score

        landing_schedule_df = next_state_df
        current_score = next_score
        it += 1
    
    return landing_schedule_df, scores


def main():
    print("\n" + "=" * 72)
    print("=" + "Welcome to the Airport Landing Scheduler".center(70) + "=")
    print("=" * 72)
    num_airplanes = get_input("Enter the number of airplanes for the simulation (between 1-1440): ", 
                              type_=int, min_=1, max_=1440, 
                              header="Simulation Setup - Number of Airplanes")
    min_fuel = get_input("Enter the minimum fuel level (in liters, between 1000-5000): ", 
                         type_=float, min_=1000, max_=5000, 
                         header="Simulation Setup - Minimum Fuel Level")
    max_fuel = get_input("Enter the maximum fuel level (in liters, between 1000-5000): ", 
                         type_=float, min_=min_fuel, max_=5000, 
                         header="Simulation Setup - Maximum Fuel Level")
    min_arrival_time = get_input("Enter the minimum expected arrival time (in minutes, between 10-1440): ", 
                                 type_=float, min_=10, max_=1440, 
                                 header="Simulation Setup - Minimum Arrival Time")
    max_arrival_time = get_input("Enter the maximum expected arrival time (in minutes, between 10-1440): ", 
                                 type_=float, min_=min_arrival_time, max_=1440, 
                                 header="Simulation Setup - Maximum Arrival Time")

    airplane_stream = generate_airplane_stream(num_airplanes, min_fuel, max_fuel, min_arrival_time, max_arrival_time)

    pd.set_option('display.max_columns', None)
    pd.set_option('display.max_rows', None)
    pd.set_option('display.width', None)
    pd.set_option('display.max_colwidth', None)

    df_initial = pd.DataFrame(
        [(airplane.id, airplane.fuel_level, airplane.fuel_level_final, airplane.emergency_fuel,
          airplane.fuel_consumption_rate, airplane.expected_landing_time)
         for airplane in airplane_stream],
        columns=["Airplane ID", "Initial Fuel", "Final Fuel", "Emergency Fuel Level", "Consumption Rate",
                 "Expected Landing Time"])

    print("\nGenerated Airplane Stream DataFrame:")
    print(df_initial.to_string(index=False))


    algorithm_choice = select_algorithm()

    if algorithm_choice == 1:
        print("Running Hill Climbing algorithm...")
        landing_schedule_df, scores = hill_climbing_schedule_landings(airplane_stream)
        print("Hill Climbing algorithm finished.")
        print("Final landing schedule:")
        print(landing_schedule_df.to_string(index=False))
        average_score = landing_schedule_df['Score'].mean()
        print("\nAverage Score: {:.2f}".format(average_score))

    if algorithm_choice == 2:
        print("Running Simulated Annealing algorithm...")
        landing_schedule_df, best_score = simulated_annealing_schedule_landings(airplane_stream)
        print("Simulated Annealing algorithm finished.")
        print("Final landing schedule and score:")
        print(landing_schedule_df.to_string(index=False))
        average_score = landing_schedule_df['Score'].mean()
        print(f"Average Score: {average_score:.2f}")

    elif algorithm_choice == 3:
        max_iterations = get_input("Enter the maximum number of iterations for the Tabu Search algorithm (between 100-1000): ", type_=int, min_=100, max_=1000)
        max_tabu_size = get_input("Enter the maximum size of the tabu list for the Tabu Search algorithm (between 5-15): ", type_=int, min_=5, max_=15)

        print("Running Tabu Search algorithm...")
        landing_schedule_df, scores = tabu_search_schedule_landings(airplane_stream, max_iterations, max_tabu_size)
        print("Tabu Search algorithm finished.")
        print("Final landing schedule:")
        print(landing_schedule_df.to_string(index=False))
        average_score = landing_schedule_df['Score'].mean()
        print("\nAverage Score: {:.2f}".format(average_score))

    elif algorithm_choice == 4:
        print("Running Genetic Algorithm...")
        
        genetic_algorithm = GeneticAlgorithmScheduler(airplane_stream)
        
        best_schedule, best_score = genetic_algorithm.run()
        
        print("Genetic Algorithm finished.")
        print(f"Best landing schedule score: {best_score}")
        

        if 'Score' in best_schedule.columns:
            average_score = best_schedule['Score'].mean()
            print("\nAverage Score: {:.2f}".format(average_score))
        else:
            print("\nNo 'Score' column in the schedule to calculate the average.")
    print("Program finished. Exiting...")

        

if __name__ == "__main__":
    main()


