import random
import math
import pandas as pd
from simulation import (generate_airplane_stream, schedule_landings, evaluate_landing_schedule, get_successors, get_tabu_successors)
from simulation import GeneticAlgorithmScheduler

def get_input(prompt, type_=None, min_=None, max_=None, header=None):
    while True:
        if header:
            print("\n" + "-" * 72)
            print("|" + header.center(70) + "|")
            print("-" * 72)
        try:
            value = input("| " + prompt.ljust(68) + "| ")
            print("-" * 72)
            if type_ is not None:
                value = type_(value)
            if (min_ is not None and value < min_) or (max_ is not None and value > max_):
                raise ValueError(f"Value should be between {min_} and {max_}.")
            return value
        except ValueError as e:
            print("|" + f"Invalid input: {e}".center(70) + "|")
            print("-" * 72)



def select_algorithm():
    print("\n" + "-" * 72)
    print("|" + "Airport Landing Scheduler".center(70) + "|")
    print("|" + "Optimization Algorithm Selection".center(70) + "|")
    print("-" * 72)
    print("|" + "1 - Hill Climbing".ljust(69) + "|")
    print("|" + "2 - Simulated Annealing".ljust(69) + "|")
    print("|" + "3 - Tabu Search".ljust(69) + "|")
    print("|" + "4 - Genetic Algorithm".ljust(69) + "|")
    print("-" * 72)
    choice = get_input("Enter your choice (number): ", type_=int, min_=1, max_=4)  # Update max_=4
    return choice



"""
Optimize the landing schedule for airplanes using hill climbing.

This function applies the hill climbing algorithm to improve the landing schedule for airplanes. Hill climbing is a local search algorithm that iteratively moves towards the best neighboring solution in the solution space.

The algorithm marks urgent airplanes based on their fuel levels and expected landing times. It generates an initial landing schedule using the 'schedule_landings' function and initializes the current score along with a list to store scores.

The function repeatedly explores neighboring landing schedules until no improvement is found. It selects the neighboring schedule with the lowest score, assuming it as the next state. If the next score is equal to the current score, indicating no improvement, the search terminates.

The function returns the optimized landing schedule along with an empty list of scores, as hill climbing does not record scores during the search process.

@param airplane_stream: A list of airplanes to schedule for landing.
@type airplane_stream: list[Airplane]
@return: A tuple containing the optimized landing schedule (DataFrame) and an empty list of scores.
@rtype: tuple(pandas.DataFrame, list)
"""


def hill_climbing_schedule_landings(airplane_stream):
    

    # Mark urgent airplanes based on their fuel levels and expected landing times.
    for airplane in airplane_stream:
        airplane.is_urgent = (airplane.fuel_level_final < airplane.emergency_fuel or
                                airplane.remaining_flying_time < airplane.expected_landing_time)

    # Generate an initial landing schedule using the schedule_landings function.
    landing_schedule_df = schedule_landings(airplane_stream)

    # Initialize the current score and a list to store the scores of each iteration.
    current_score = evaluate_landing_schedule(landing_schedule_df, airplane_stream)
    scores = []

    # Repeat the following steps until no improvement is found.
    while True:
        #Get all neighboring landing schedules from the current schedule.
        neighbors = get_successors(landing_schedule_df, airplane_stream)

        # Assume the next state is the same as the current state and track the lowest score.
        next_state_df = landing_schedule_df
        next_score = current_score

        # Iterate over the neighboring landing schedules and find the one with the lowest score.
        for neighbor_df in neighbors:
            score = evaluate_landing_schedule(neighbor_df, airplane_stream)
            if score < next_score:
                next_state_df = neighbor_df
                next_score = score

        #If the next score is equal to the current score, the search is complete.
        if next_score == current_score:
            break

        # Update the landing schedule and the current score.
        landing_schedule_df = next_state_df
        current_score = next_score

    # Return the optimized landing schedule and the list of scores.
    return landing_schedule_df, scores


"""
Optimize the landing schedule for airplanes using simulated annealing.

This function applies the simulated annealing algorithm to improve the landing schedule for airplanes. Simulated annealing is a technique inspired by metallurgy annealing, gradually reducing temperature to explore the solution space while avoiding local optima.

The algorithm begins with an initial landing schedule generated by 'schedule_landings'. It iteratively adjusts the schedule to improve its score, considering both better and worse solutions based on a probability function and current temperature.

@param airplane_stream: A list of airplanes to schedule for landing.
@type airplane_stream: list[Airplane]
@return: A tuple containing the optimized landing schedule (DataFrame) and its score.
@rtype: tuple(pandas.DataFrame, float)
"""


def simulated_annealing_schedule_landings(airplane_stream):
    # Função adaptada para calcular a pontuação de uma programação de pouso
    def calculate_score(schedule_df, airplane_stream):
        total_score = 0
        for index, row in schedule_df.iterrows():
            airplane = next((ap for ap in airplane_stream if ap.id == row['Airplane ID']), None)
            if airplane:
                is_urgent = airplane.fuel_level_final < airplane.emergency_fuel or airplane.remaining_flying_time < row['Actual Landing Time']
                difference = abs(airplane.expected_landing_time - row['Actual Landing Time'])
                urgency_penalty = 100 if is_urgent else 0
                score = 1000 - difference - urgency_penalty
                total_score += score
        return total_score

    # Função adaptada para gerar um único vizinho da programação atual
    def get_schedule_neighbor(schedule_df):
        neighbor_df = schedule_df.copy()
        i, j = random.sample(range(len(neighbor_df)), 2)
        # Troca os horários de pouso de dois aviões aleatoriamente
        neighbor_df.iloc[i], neighbor_df.iloc[j] = neighbor_df.iloc[j].copy(), neighbor_df.iloc[i].copy()
        return neighbor_df

    current_schedule = schedule_landings(airplane_stream)
    current_score = calculate_score(current_schedule, airplane_stream)
    best_schedule = current_schedule
    best_score = current_score
    T = 1.0  # Temperatura inicial alta
    T_min = 0.001  # Temperatura mínima
    alpha = 0.9  # Taxa de resfriamento

    while T > T_min:
        new_schedule = get_schedule_neighbor(current_schedule)
        new_score = calculate_score(new_schedule, airplane_stream)
        delta = new_score - current_score
        if delta > 0 or math.exp(delta / T) > random.random():
            current_schedule = new_schedule
            current_score = new_score
        T *= alpha
    return best_schedule, best_score

"""
Optimize the landing schedule for airplanes using tabu search.

This function applies the tabu search algorithm to improve the landing schedule for airplanes. Tabu search is a metaheuristic search method that guides the search process to explore the solution space efficiently while avoiding getting trapped in local optima.

The algorithm begins by determining if an airplane is urgent based on its fuel level and remaining flying time. It then initializes variables, including the landing schedule, current score, a list of scores, and a tabu list.

The function iterates through the search process until it reaches the maximum number of iterations specified. During each iteration, it generates neighboring solutions from the current solution and evaluates their scores. It selects the best solution among neighbors and considers it for the next iteration while also considering solutions in the tabu list.

The search process continues until the maximum number of iterations is reached. The function returns the optimized landing schedule along with a list of scores recorded during the search process.

@param airplane_stream: A list of airplanes to schedule for landing.
@type airplane_stream: list[Airplane]
@param max_iterations: The maximum number of iterations for the tabu search algorithm. Default is 1000.
@type max_iterations: int, optional
@param max_tabu_size: The maximum size of the tabu list. Default is 10.
@type max_tabu_size: int, optional
@return: A tuple containing the optimized landing schedule (DataFrame) and a list of scores recorded during the search process.
@rtype: tuple(pandas.DataFrame, list[float])
"""


def tabu_search_schedule_landings(airplane_stream, max_iterations=1000, max_tabu_size=10):
    # Verificar se um avião é urgente
    for airplane in airplane_stream:
        airplane.is_urgent = airplane.fuel_level_final < airplane.emergency_fuel or airplane.remaining_flying_time < airplane.expected_landing_time
    
    # Declaração de variáveis
    landing_schedule_df = schedule_landings(airplane_stream)
    current_score = evaluate_landing_schedule(landing_schedule_df, airplane_stream)
    scores = []
    tabu_list = []
    it = 0

    # Ciclo while que efetua a busca tabu até atingir o número máximo de iterações
    while it < max_iterations:
        # Aqui geram-se os vizinhos da solução/estado atual e guarda-se o score da solução inicial na lista de scores
        # (como melhor solução encontrada até ao momento)
        neighbors = get_tabu_successors(landing_schedule_df, airplane_stream, tabu_list, current_score)
        next_state_df = landing_schedule_df
        scores.append(current_score)
        next_score = current_score

        best_solution_df = landing_schedule_df
        best_solution_score = evaluate_landing_schedule(landing_schedule_df, airplane_stream)

        # Iteração entre os vizinhos para encontrar a melhor solução entre eles
        for neighbor_df in neighbors:
            score = evaluate_landing_schedule(neighbor_df, airplane_stream)
            if score < best_solution_score:
                best_solution_df = neighbor_df
                best_solution_score = score
            if neighbor_df.to_string() not in tabu_list and score < next_score:
                next_state_df = neighbor_df
                next_score = score

        if next_score >= current_score:
            next_state_df = best_solution_df
            next_score = best_solution_score

        landing_schedule_df = next_state_df
        current_score = next_score
        tabu_list.append(next_state_df.to_string())
        if len(tabu_list) > max_tabu_size:
            tabu_list.pop(0)
        it += 1
    
    return landing_schedule_df, scores


"""
Optimize the landing schedule for airplanes using a genetic algorithm.

This function applies a genetic algorithm to optimize the landing schedule for airplanes. Genetic algorithms are population-based metaheuristic optimization techniques inspired by the principles of natural selection and genetics.

The algorithm begins by generating an initial population of landing schedules using the 'generate_initial_schedule' function. It then iterates through a predefined number of generations, during each of which it evaluates the fitness of each individual (schedule) in the population.

In each generation, the algorithm selects parents based on their fitness scores, performs crossover to create offspring, and applies mutation to introduce genetic diversity. Elitism is implemented by preserving the best individuals from each generation.

After the main genetic algorithm loop, the function selects the top individuals from the best generations, replacing the worst individuals in the current population. It returns the best landing schedule found along with its corresponding score.

@param airplane_stream: A list of airplanes to schedule for landing.
@type airplane_stream: list[Airplane]
@param population_size: The size of the population. Default is 50.
@type population_size: int, optional
@param generations: The number of generations to run the genetic algorithm. Default is 50.
@type generations: int, optional
@param crossover_rate: The probability of crossover between parents. Default is 0.8.
@type crossover_rate: float, optional
@param mutation_rate: The probability of mutation for each gene. Default is 0.1.
@type mutation_rate: float, optional
@return: A tuple containing the best optimized landing schedule (DataFrame) and its corresponding score.
@rtype: tuple(pandas.DataFrame, float)
"""




#pertence ao sa
def calculate_efficiency_score(schedule_df, airplane_stream):
    max_score_per_plane = 1000
    efficiency_scores = []

    for index, row in schedule_df.iterrows():
        airplane = next((ap for ap in airplane_stream if ap.id == row['Airplane ID']), None)
        if airplane:
            # Calcula o desvio do tempo previsto
            time_deviation = abs(airplane.expected_landing_time - row['Actual Landing Time'])

            # Calcula a eficiência
            # A eficiência será o score máximo menos o desvio do tempo, a menos que o avião seja urgente.
            efficiency_score = max(0, max_score_per_plane - time_deviation)
            if row['Urgent']:
                efficiency_score = max(0, efficiency_score - 100)  # Penalidade de 50 pontos para urgência

            efficiency_scores.append(efficiency_score)
        else:
            efficiency_scores.append(None)  # Caso não encontre o avião correspondente

    schedule_df['Score'] = efficiency_scores
    return schedule_df

    # score inicial: 100
    # desvio : 30 min dif (100-30=70)
    # urgencia 70-50 = 20
    # efic final: 20%
    


def main():
    print("\n" + "=" * 72)
    print("=" + "Welcome to the Airport Landing Scheduler".center(70) + "=")
    print("=" * 72)
    num_airplanes = get_input("Enter the number of airplanes for the simulation (between 1-1440): ", 
                              type_=int, min_=1, max_=1440, 
                              header="Simulation Setup - Number of Airplanes")
    min_fuel = get_input("Enter the minimum fuel level (in liters, between 1000-5000): ", 
                         type_=float, min_=1000, max_=5000, 
                         header="Simulation Setup - Minimum Fuel Level")
    max_fuel = get_input("Enter the maximum fuel level (in liters, between 1000-5000): ", 
                         type_=float, min_=min_fuel, max_=5000, 
                         header="Simulation Setup - Maximum Fuel Level")
    min_arrival_time = get_input("Enter the minimum expected arrival time (in minutes, between 10-1440): ", 
                                 type_=float, min_=10, max_=1440, 
                                 header="Simulation Setup - Minimum Arrival Time")
    max_arrival_time = get_input("Enter the maximum expected arrival time (in minutes, between 10-1440): ", 
                                 type_=float, min_=min_arrival_time, max_=1440, 
                                 header="Simulation Setup - Maximum Arrival Time")

    airplane_stream = generate_airplane_stream(num_airplanes, min_fuel, max_fuel, min_arrival_time, max_arrival_time)

    pd.set_option('display.max_columns', None)
    pd.set_option('display.max_rows', None)
    pd.set_option('display.width', None)
    pd.set_option('display.max_colwidth', None)

    df_initial = pd.DataFrame(
        [(airplane.id, airplane.fuel_level, airplane.fuel_level_final, airplane.emergency_fuel,
          airplane.fuel_consumption_rate, airplane.expected_landing_time)
         for airplane in airplane_stream],
        columns=["Airplane ID", "Initial Fuel", "Final Fuel", "Emergency Fuel Level", "Consumption Rate",
                 "Expected Landing Time"])

    print("\nGenerated Airplane Stream DataFrame:")
    print(df_initial.to_string(index=False))


    algorithm_choice = select_algorithm()

    if algorithm_choice == 1:
        print("Running Hill Climbing algorithm...")
        landing_schedule_df, scores = hill_climbing_schedule_landings(airplane_stream)
        print("Hill Climbing algorithm finished.")
        print("Final landing schedule:")
        print(landing_schedule_df.to_string(index=False))
        average_score = landing_schedule_df['Score'].mean()
        print("\nAverage Score: {:.2f}".format(average_score))

    elif algorithm_choice == 2:
        print("Running Simulated Annealing algorithm...")
        landing_schedule_df, score = simulated_annealing_schedule_landings(airplane_stream)
        landing_schedule_df = calculate_efficiency_score(landing_schedule_df, airplane_stream)
        print("Simulated Annealing algorithm finished.")
        print("Final landing schedule and score:")
        print(landing_schedule_df.to_string(index=False))

    elif algorithm_choice == 3:
        max_iterations = get_input("Enter the maximum number of iterations for the Tabu Search algorithm (between 100-1000): ", type_=int, min_=100, max_=1000)
        max_tabu_size = get_input("Enter the maximum size of the tabu list for the Tabu Search algorithm (between 5-15): ", type_=int, min_=5, max_=15)

        print("Running Tabu Search algorithm...")
        landing_schedule_df, scores = tabu_search_schedule_landings(airplane_stream, max_iterations, max_tabu_size)
        print("Tabu Search algorithm finished.")
        print("Final landing schedule:")
        print(landing_schedule_df.to_string(index=False))
        average_score = landing_schedule_df['Score'].mean()
        print("\nAverage Score: {:.2f}".format(average_score))

    elif algorithm_choice == 4:
        print("Running Genetic Algorithm...")
        
        genetic_algorithm = GeneticAlgorithmScheduler(airplane_stream)
        
        best_schedule, best_score = genetic_algorithm.run()
        
        print("Genetic Algorithm finished.")
        print(f"Best landing schedule score: {best_score}")
        

        if 'Score' in best_schedule.columns:
            average_score = best_schedule['Score'].mean()
            print("\nAverage Score: {:.2f}".format(average_score))
        else:
            print("\nNo 'Score' column in the schedule to calculate the average.")
    print("Program finished. Exiting...")

        

if __name__ == "__main__":
    main()


